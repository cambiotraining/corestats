{
  "hash": "b0c357e52f3179d8447e90ac3fc00a86",
  "result": {
    "markdown": "---\ntitle: \"Wilcoxon signed rank test\"\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\nA Wilcoxon signed-rank test is an alternative to a paired t-test. It does not require that the data are drawn from normal distributions, but it does require that the distribution of the differences is symmetric. We're effectively testing to see if the median of the differences between the two samples differs significantly from zero.\n\n## Libraries and functions\n\n::: {.callout-note collapse=\"true\"}\n## Click to expand\n\n::: {.panel-tabset group=\"language\"}\n## tidyverse\n\n### Libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A collection of R packages designed for data science\nlibrary(tidyverse)\n\n# Converts stats functions to a tidyverse-friendly format\nlibrary(rstatix)\n```\n:::\n\n\n### Functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Performs a one-sample t-test, Student's t-test\n# and Welch's t-test in later sections\nrstatix::t_test()\n\n# Performs a Shapiro-Wilk test for normality\nrstatix::shapiro_test()\n\n# Plots a Q-Q plot for comparison with a normal distribution\nggplot2::stat_qq()\n\n# Adds a comparison line to the Q-Q plot\nggplot2::stat_qq_line()\n\n# Plots jittered points by adding a small amount of random variation\n# to each point, to handle overplotting\nggplot2::geom_jitter()\n\n# \"Widens\" the data, increasing the number of columns\ntidyr::pivot_wider()\n```\n:::\n\n\n## R\n\n### Functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Reshapes a data frame from 'long' to 'wide' and vice versa\nstats::reshape()\n\n# Performs a one-sample t-test, Student's t-test\n# and Welch's t-test in later sections\nstats::t.test()\n\n# Plots a Q-Q plot for comparison with a normal distribution\nstats::qqnorm()\n\n# Adds a comparison line to the Q-Q plot\nstats::qqline()\n\n# Performs a Shapiro-Wilk test for normality\nstats::shapiro.test()\n```\n:::\n\n\n## Python\n\n| Libraries                                                             | Description                                                              |\n|:----------------------|:------------------------------------------------|\n| [`pandas`](https://pandas.pydata.org/docs/getting_started/index.html) | A Python data analysis and manipulation tool.                            |\n| [`pingouin`](https://pingouin-stats.org)                              | A Python module developed to have simple yet exhaustive stats functions. |\n| [`plotnine`](https://plotnine.readthedocs.io/en/stable/)              | The Python equivalent of `ggplot2`.                                      |\n\n| Functions                                                                                                               | Description                                                                                |\n|:-----------------------------------|:-----------------------------------|\n| [`pandas.read_csv`](https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html)                                  | Reads in a `.csv` file.                                                                    |\n| [`pingouin.wilcoxon()`](https://pingouin-stats.org/generated/pingouin.wilcoxon.html#pingouin.wilcoxon)                  | Tests the null hypothesis that two related paired samples come from the same distribution. |\n| [`pingouin.normality()`](https://pingouin-stats.org/generated/pingouin.normality.html)                                  | Performs the Shapiro-Wilk test for normality.                                              |\n| [`plotnine.stats.stat_qq()`](https://plotnine.readthedocs.io/en/stable/generated/plotnine.stats.stat_qq.html)           | Plots a Q-Q plot for comparison with a normal distribution.                                |\n| [`plotnine.stats.stat_qq_line()`](https://plotnine.readthedocs.io/en/stable/generated/plotnine.stats.stat_qq_line.html) | Adds a comparison line to the Q-Q plot.                                                    |\n:::\n:::\n\n## Data and hypotheses\n\nUsing the `cortisol` dataset from before we form the following null and alternative hypotheses:\n\n-   $H_0$: The median of the difference in cortisol levels between the two groups is 0 $(\\mu M = \\mu E)$\n-   $H_1$: The median of the difference in cortisol levels between the two groups is not 0 $(\\mu M \\neq \\mu E)$\n\nWe use a two-tailed Wilcoxon signed-rank test to see if we can reject the null hypothesis.\n\n## Summarise and visualise\n\nAlready implemented previously.\n\n## Assumptions\n\nThese have been checked previously.\n\n## Implement and interpret the test\n\nPerform a two-tailed, Wilcoxon signed-rank test:\n\n::: {.panel-tabset group=\"language\"}\n## tidyverse\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# perform the test\ncortisol %>% \n  wilcox_test(cortisol ~ time,\n              alternative = \"two.sided\",\n              paired = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 7\n  .y.      group1  group2     n1    n2 statistic        p\n* <chr>    <chr>   <chr>   <int> <int>     <dbl>    <dbl>\n1 cortisol evening morning    20    20        13 0.000168\n```\n:::\n:::\n\n\n-   The first argument gives the formula\n-   The second argument gives the type of alternative hypothesis and must be one of `two.sided`, `greater` or `less`\n-   The third argument says that the data are paired\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwilcox.test(cortisol ~ time,\n            alternative = \"two.sided\",\n            paired = TRUE,\n            data = cortisol_r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tWilcoxon signed rank exact test\n\ndata:  cortisol by time\nV = 13, p-value = 0.0001678\nalternative hypothesis: true location shift is not equal to 0\n```\n:::\n:::\n\n\n-   The first argument gives the formula\n-   The second argument gives the type of alternative hypothesis and must be one of `two.sided`, `greater` or `less`\n-   The third argument indicates that the test is paired\n-   The last argument is the data set\n\n## Python\n\nWe'll use the wide format data set that we created previously:\n\n\n::: {.cell}\n\n```{.python .cell-code}\npg.wilcoxon(x = cortisol_diff_py[\"evening\"],\n            y = cortisol_diff_py[\"morning\"],\n            alternative = \"two-sided\",\n            correction = True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          W-val alternative     p-val      RBC  CLES\nWilcoxon   13.0   two-sided  0.000168 -0.87619  0.16\n```\n:::\n:::\n\n:::\n\nThe p-value is given in the `p` column (p-value = 0.000168). Given that this is less than 0.05 we can still reject the null hypothesis.\n\n> A two-tailed, Wilcoxon signed-rank test indicated that the median cortisol level in adult females differed significantly between the morning (320.5 nmol/l) and the evening (188.9 nmol/l) (V = 13, p = 0.00017).\n\n<br />\n\n## Exercise: Deer legs\n\nUsing the following data on deer legs (yes, really!), test the null hypothesis that the fore and hind legs of the deer in this data set are the same length.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 2\n   hindleg foreleg\n     <dbl>   <dbl>\n 1     142     138\n 2     140     136\n 3     144     147\n 4     144     139\n 5     142     143\n 6     146     141\n 7     149     143\n 8     150     145\n 9     142     136\n10     148     146\n```\n:::\n:::\n\n\nDo these results provide any evidence to suggest that fore- and hind-leg length differ in deer?\n\n1.  Write down the null and alternative hypotheses\n2.  Import the data from `data/CS1-deer.csv`\n3.  Summarise and visualise the data\n4.  Check your assumptions (normality and variance) using appropriate tests\n5.  Discuss with your (virtual) neighbour which test is most appropriate?\n6.  Perform the test\n7.  Write down a sentence that summarises the results that you have found\n\n::: {.callout-tip collapse=\"true\"}\n## Answer\n\n### Hypotheses\n\n$H_0$ : foreleg average (mean or median) $=$ hindleg average (mean or median)\n\n$H_1$ : foreleg average $\\neq$ hindleg average\n\n### Import data, summarise and visualise\n\nFirst of all, we need to get the data into a tidy format (every variable is a column, each observation is a row). Doing this in Excel, and adding a ID gives us:\n\n::: {.panel-tabset group=\"language\"}\n## tidyverse\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load the data\ndeer <- read_csv(\"data/CS1-deer.csv\")\n\n# have a look\ndeer\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 20 × 3\n      id leg     length\n   <dbl> <chr>    <dbl>\n 1     1 hindleg    142\n 2     2 hindleg    140\n 3     3 hindleg    144\n 4     4 hindleg    144\n 5     5 hindleg    142\n 6     6 hindleg    146\n 7     7 hindleg    149\n 8     8 hindleg    150\n 9     9 hindleg    142\n10    10 hindleg    148\n11     1 foreleg    138\n12     2 foreleg    136\n13     3 foreleg    147\n14     4 foreleg    139\n15     5 foreleg    143\n16     6 foreleg    141\n17     7 foreleg    143\n18     8 foreleg    145\n19     9 foreleg    136\n20    10 foreleg    146\n```\n:::\n:::\n\n\nThe ordering of the data is important here; the first hind leg row corresponds to the first fore leg row, the second to the second and so on. To indicate this we use an `id` column, where each observation has a unique ID.\n\nLet's look at the data and see what we can see.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# summarise the data\ndeer %>% \n  select(-id) %>% \n  get_summary_stats(type = \"common\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 10\n  variable     n   min   max median   iqr  mean    sd    se    ci\n  <chr>    <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1 length      20   136   150    143  5.25  143.  4.01 0.896  1.88\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# or even summarise by leg type\ndeer %>% \n  select(-id) %>% \n  group_by(leg) %>% \n  get_summary_stats(type = \"common\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 11\n  leg     variable     n   min   max median   iqr  mean    sd    se    ci\n  <chr>   <chr>    <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1 foreleg length      10   136   147    142  6.25  141.  4.03  1.27  2.88\n2 hindleg length      10   140   150    144  5.5   145.  3.40  1.08  2.43\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# we can also visualise the data\ndeer %>% \n  ggplot(aes(x = leg, y = length)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](cs1_practical_two-sample-paired-wilcoxon_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nAll of this suggests that there might be a difference between the legs, with hind legs being longer than forelegs. However, this representation obscures the fact that we have *paired* data. What we really need to look at is the difference in leg length for each observation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a data set that contains the difference in leg length\nleg_diff <- deer %>% \n  pivot_wider(names_from = leg, values_from = length) %>% \n  mutate(leg_diff = hindleg - foreleg)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# plot the difference in leg length\nleg_diff %>% \n  ggplot(aes(y = leg_diff)) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](cs1_practical_two-sample-paired-wilcoxon_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\nAdditionally, we can also plot the data by observation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# plot the data by observation\ndeer %>% \n  ggplot(aes(x = leg, y = length, group = id)) +\n  geom_point() +\n  geom_line()\n```\n\n::: {.cell-output-display}\n![](cs1_practical_two-sample-paired-wilcoxon_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndeer_r <- read.csv(\"data/CS1-deer.csv\")\n\nhead(deer_r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id     leg length\n1  1 hindleg    142\n2  2 hindleg    140\n3  3 hindleg    144\n4  4 hindleg    144\n5  5 hindleg    142\n6  6 hindleg    146\n```\n:::\n:::\n\n\nThe ordering of the data is important here; the first hind leg row corresponds to the first fore leg row, the second to the second and so on. To indicate this we use an `id` column, where each observation has a unique ID.\n\nLet's look at the data and see what we can see.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# summarise the data\nsummary(deer_r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       id           leg                length     \n Min.   : 1.0   Length:20          Min.   :136.0  \n 1st Qu.: 3.0   Class :character   1st Qu.:140.8  \n Median : 5.5   Mode  :character   Median :143.0  \n Mean   : 5.5                      Mean   :143.1  \n 3rd Qu.: 8.0                      3rd Qu.:146.0  \n Max.   :10.0                      Max.   :150.0  \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# or even summarise by leg type\naggregate(length ~ leg, data = deer_r, summary)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      leg length.Min. length.1st Qu. length.Median length.Mean length.3rd Qu.\n1 foreleg      136.00         138.25        142.00      141.40         144.50\n2 hindleg      140.00         142.00        144.00      144.70         147.50\n  length.Max.\n1      147.00\n2      150.00\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# we can also visualise the data\nboxplot(length ~ leg, data = deer_r)\n```\n\n::: {.cell-output-display}\n![](cs1_practical_two-sample-paired-wilcoxon_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\nAll of this suggests that there might be a difference between the legs, with hind legs being longer than forelegs. However, this representation obscures the fact that we have *paired* data. What we really need to look at is the difference in leg length for each observation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleg_diff_r <- reshape(deer_r,\n        idvar = \"id\",\n        timevar = \"leg\",\n        direction = \"wide\")\n\n# calculate difference in leg length\nleg_diff_r$leg_diff <- leg_diff_r$length.hindleg - leg_diff_r$length.foreleg\n\nhead(leg_diff_r)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  id length.hindleg length.foreleg leg_diff\n1  1            142            138        4\n2  2            140            136        4\n3  3            144            147       -3\n4  4            144            139        5\n5  5            142            143       -1\n6  6            146            141        5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# plot the difference in leg length\nboxplot(leg_diff_r$leg_diff)\n```\n\n::: {.cell-output-display}\n![](cs1_practical_two-sample-paired-wilcoxon_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\nAdditionally, we can also plot the data by observation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# plot the data by observation\nmatplot(t(leg_diff_r[ , 2:3]),\n        pch = 1,\n        type = c(\"b\"),\n        col = 1:10)\n```\n\n::: {.cell-output-display}\n![](cs1_practical_two-sample-paired-wilcoxon_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\nAgain, as far as I am aware of, there isn't a straightforward method of plotting paired data using the base R functionality. Hence the data gymnastics:\n\n-   the default `plot()` function doesn't support this - the standard `matplot()` function does\n-   the `t` function transposes the data, and I'm only selecting the second and third columns (`[ , 2:3]`) which contain the paired leg measurements.\n-   to group (pair) the data, we're using colours, one for each of the 10 observations (`col = 1:10`)\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# load the data\ndeer_py = pd.read_csv(\"data/CS1-deer.csv\")\n\n# have a look\ndeer_py.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   id      leg  length\n0   1  hindleg     142\n1   2  hindleg     140\n2   3  hindleg     144\n3   4  hindleg     144\n4   5  hindleg     142\n```\n:::\n:::\n\n\nThe ordering of the data is important here; the first hind leg row corresponds to the first fore leg row, the second to the second and so on. To indicate this we use an `id` column, where each observation has a unique ID.\n\nLet's look at the data and see what we can see.\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# summarise the data\ndeer_py.describe()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              id      length\ncount  20.000000   20.000000\nmean    5.500000  143.050000\nstd     2.946898    4.006245\nmin     1.000000  136.000000\n25%     3.000000  140.750000\n50%     5.500000  143.000000\n75%     8.000000  146.000000\nmax    10.000000  150.000000\n```\n:::\n:::\n\n\nWe can also summarise by leg type:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndeer_py.groupby(\"leg\")[\"length\"].describe()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         count   mean       std    min     25%    50%    75%    max\nleg                                                                \nforeleg   10.0  141.4  4.033196  136.0  138.25  142.0  144.5  147.0\nhindleg   10.0  144.7  3.400980  140.0  142.00  144.0  147.5  150.0\n```\n:::\n:::\n\n\nIt might be more helpful to look at the *difference* in leg length. In order to calculate that, we need to reformat our data into a 'wide' format first:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# reformat the data into a 'wide' format\nleg_diff_py = pd.pivot(deer_py,\n                       index = \"id\",\n                       columns = \"leg\",\n                       values = \"length\")\n\n# have a look at the format\nleg_diff_py.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nleg  foreleg  hindleg\nid                   \n1        138      142\n2        136      140\n3        147      144\n4        139      144\n5        143      142\n```\n:::\n:::\n\n\nNext, we can add a new column `leg_diff` that contains the leg difference:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# add a new column with difference between\n# hind and fore leg length\nleg_diff_py[\"leg_diff\"] = leg_diff_py[\"hindleg\"].subtract(leg_diff_py[\"foreleg\"])\n \n```\n:::\n\n\nFinally, we can visualise this:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# we can also visualise the data\n(\n  ggplot(leg_diff_py,\n    aes(x = \"1\",\n        y = \"leg_diff\"))\n  + geom_boxplot()\n)\n```\n\n::: {.cell-output-display}\n![](cs1_practical_two-sample-paired-wilcoxon_files/figure-html/unnamed-chunk-31-1.png){width=614}\n:::\n:::\n\n\nAll of this suggests that there might be a difference between the legs, with hind legs being longer than forelegs. However, this representation obscures the fact that we have *paired* data. What we really need to look at is the difference in leg length for each observation:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# plot paired observations\n(\n  ggplot(deer_py,\n    aes(x = \"leg\",\n        y = \"length\",\n        group = \"id\"))\n  + geom_point()\n  + geom_line()\n)\n```\n\n::: {.cell-output-display}\n![](cs1_practical_two-sample-paired-wilcoxon_files/figure-html/unnamed-chunk-32-3.png){width=614}\n:::\n:::\n\n:::\n\nAll of this gives us a much clearer picture. It looks as though the hindlegs are about 4 cm longer than the forelegs, on average. It also suggests that our leg differences might not be normally distributed (the data look a bit skewed in the boxplot).\n\n### Assumptions\n\nWe need to consider the distribution of the *difference* in leg lengths rather than the individual distributions.\n\n::: {.panel-tabset group=\"language\"}\n## tidyverse\n\nShapiro-Wilk test:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# perform Shapiro-Wilk test on leg differences\nleg_diff %>% \n  shapiro_test(leg_diff)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 3\n  variable statistic      p\n  <chr>        <dbl>  <dbl>\n1 leg_diff     0.814 0.0212\n```\n:::\n:::\n\n\nQ-Q plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a Q-Q plot\nleg_diff %>% \n  ggplot(aes(sample = leg_diff)) +\n  stat_qq() +\n  stat_qq_line(colour = \"red\")\n```\n\n::: {.cell-output-display}\n![](cs1_practical_two-sample-paired-wilcoxon_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\n## R\n\nShapiro-Wilk test:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# perform Shapiro-Wilk test on leg differences\nshapiro.test(leg_diff_r$leg_diff)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tShapiro-Wilk normality test\n\ndata:  leg_diff_r$leg_diff\nW = 0.81366, p-value = 0.02123\n```\n:::\n:::\n\n\nQ-Q plot:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a Q-Q plot\nqqnorm(leg_diff_r$leg_diff)\nqqline(leg_diff_r$leg_diff, col = \"red\")\n```\n\n::: {.cell-output-display}\n![](cs1_practical_two-sample-paired-wilcoxon_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n:::\n\n\n## Python\n\nShapiro-Wilk test:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# perform Shapiro-Wilk test on leg length differences\npg.normality(leg_diff_py[\"leg_diff\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                 W      pval  normal\nleg_diff  0.813656  0.021235   False\n```\n:::\n:::\n\n\nCreate the Q-Q plot:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# create the Q-Q plot\n(\n  ggplot(leg_diff_py,\n    aes(sample = \"leg_diff\"))\n    + stat_qq()\n    + stat_qq_line(colour = \"red\")\n)\n```\n\n::: {.cell-output-display}\n![](cs1_practical_two-sample-paired-wilcoxon_files/figure-html/unnamed-chunk-38-1.png){width=614}\n:::\n:::\n\n:::\n\nBoth our Shapiro-Wilk test and our Q-Q plot suggest that the difference data aren't normally distributed, which rules out a paired t-test. We should therefore consider a paired Wilcoxon test next. Remember that this test requires that the distribution of differences be symmetric, whereas our box plot from before suggested that the data were very much skewed.\n\nThis means that we're not able to perform a paired Wilcoxon test either!\n\n### Conclusions\n\nSo, frustratingly, neither of the tests at our disposal are appropriate for this data set. The differences in fore leg and hind leg lengths are neither normal enough for a paired t-test nor are they symmetric enough for a Wilcoxon test. We also don't have enough data to just use the t-test (we'd need more than 30 points or so). So what do we do in this situation? Well, the answer is that there aren't actually any traditional statistical tests that are valid for this data set as it stands!\n\nThere are two options available to someone:\n\n1.  try transforming the raw data (take logs, square root, reciprocals) and hope that one of them leads to a modified data set that satisfies the assumptions of one of the tests we've covered, or\n2.  use a permutation test approach (which would work but is beyond the scope of this course).\n\nThe reason I included this example in the first practical is purely to illustrate how a very simple data set with an apparently clear message (leg lengths differ within deer) can be intractable. You don't need to have very complex data sets before you go beyond the capabilities of classical statistics.\n\nAs Jeremy Clarkson [would put it](https://www.quotes.net/mquote/941330):\n\n> And on that bombshell, it's time to end. Goodnight!\n:::\n\n## Key points\n\n::: callout-note\n-   We use two-sample tests to see if two samples of continuous data come from the same parent distribution\n-   This essentially boils down to testing if the mean or median differs between the two samples\n-   There are 5 key two-sample tests: Student's t-test, Welch's t-test, Mann-Whitney U test, paired t-test and Wilcoxon signed-rank test\n-   Which one you use depends on normality of the distribution, sample size, paired or unpaired data and variance of the samples\n-   Parametric tests are used if the data are normally distributed or the sample size is large\n-   Non-parametric tests are used if the data are not normally distributed *and* the sample size is small\n-   Equality of variance then determines which test is appropriate\n-   You three questions to determine the test:\n    1.  is my data paired?\n    2.  do I need a parametric or non-parametric test\n    3.  can I assume equality of variance?\n:::\n",
    "supporting": [
      "cs1_practical_two-sample-paired-wilcoxon_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}